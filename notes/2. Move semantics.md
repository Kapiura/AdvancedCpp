# Agenda
1. r-value, x-value, l-value
2. referencja &, &&
3. Wielka trójka, wielka piątka
4. std::move
5. copy elision, named return value optimisation
6. dlaczego move semantics ma znaczenie dla klas typu std::vector, ale nie dla np std::complex
7. Co to jest referencja uniwersalna

# Po co
- Bo wskaźniki z C są paskudne i nikt nie lubi ich używać
- Ale wskazniki tutaj odgrywają kluczową role
# Uchwyty
- Mamy sobie vectora
Vector:
- informacje pomocnicze
- uchwyt - wskaznikl - stos
- wskazuje on na sterte gdzie sa nasze dane
Po co takie cos:
- Ułatwia zarządzanie zasobami
- Umożliwia zmniejszenie użyciu stosu programu
- Ułatwia optymalizacje pewnych operacji swap
- Taki uchwyt danych ma wiekszosc kontenerow

# Kopia Głęboka
- Jest kosztowna
- Zawsze bezpieczna
- Polega na doslownie zrobieniu drugiego obiektu ktory wskazuje na dane te same jedynie pod wzgledem wartosci, patrzac na adresy są zupełnie inne
# Kopia Płytka
- tanie
- czasami bywa niebezpieczne
- Podstawa mechanizmu reference counting
- Polega na stworzeniu takiego samego obiektu i wskaznik wskauzje na te same dane
# Przekazywanie argumentu
- Kopiowanie głębokie - kosztowne
- Wynik funkcji umiera zaraz po zakończeniu funkcji

- przez wartość - kosztowne kopiowanie
- przez referencje - tylko do obiektów mających adres l-wartość
- przez stałą referencje - uniwersalne ale przy przekazaniu obiektu bezadresowego r-wartosci, po cichu jest wykonywana kopia co kosztuje
- przez wskaźnik - jak referencja ale nikt nie lubi ich jak łysych bo mogli byc rudzi

Przez wartość
`void f(int n)`
`f(10) f(x) f(10+x)`
Przez referencje
`void f(int& n)`
`f(x)`
Przez stała referencje
`void f(const int& n);`
`f(10) - ciche kopiowanie`
`f(x)`
`f(10+x) - ciche kopiowanie`

Jak działa referen cja
- Jeżeli argument ma adres, to jest przekazany do funkcji
- Jesli nie ma adresu to najpierw jest tworzona kopia jego wartosci, a następnie taka funkcja dostaje jej adres

# L-wartość R-wartość
- L-wartości - lewe strony operatora= mają adresy (RAM)
- R-wartośći - nie maja adresóœ np zmienne tymczasowe, przechowywane w rejestrach, cache, stałe wkompilowane w kod
```
int x = 9; // l
x+9; // r
sin(x) // r
std::cout // l
sin; // l
std::vector<int> v; // l
5 // r
```

# Omijanie zbędnego kopiowanie głębokiego
- Problemem są obiekty tymczasowe
- Bez sensu kopiować cos co zaraz deda robi


Rozwiązaniem jest referencja do r-wartości &&
```
int x = 9 //
int &b = x  // l-wartosc do obiektu
int &&c = 9; // r-wartosc do stalej
int &d = 9; // niemowlziwe, nie ma adresu
int &&e = x; // niemozliwe, ma adres
```
Czyli co to za sraka ta && referencja do r-wartosci
- Kompilator generuje kopie wartosci i umieszcza w zmiennej jej adres
- Przypomina to obsluge stalej referencji - const &

A po co to gowno jest
- Majac & i && można na poziomie języka czyli automatycznie rozróżniac przekazywanie do i z funkcji parametrow majacych adres i nie majacych
- Pozwala na automatyczna optymalizacje obslugi tych bez adresu poprzez przeniesienie zamist glebokiej kopii

# Konstruktor przenoszący
```
Wektor(Wektor&& rhs)
{
	// przeniesienie prawa wlasnosci do danych
	_size = rhs._size;
	_data = rhs._data;
	// wyzerowanie oryginalu
	rhs._size = 0;
	rhs._data = nullptr;
}
```
- zmiana właściciela
- wyzerowanie orygnialu dlatego sie nie uzywa const